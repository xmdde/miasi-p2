[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module generate('http://www.eclipse.org/uml2/5.0.0/UML')]


[template public generatePython(board : Model)]
[file('GameBoard.py', false, 'UTF-8')]
[comment @main/]

[comment -- 0. Generowanie klasy bazowej Piece --/]
[generatePiece(board)/]

[comment -- 1. Generowanie klas figur (Pawn, Rook, itd.) --/]
[for (c : Class |
    board.packagedElement
        ->filter(InstanceSpecification)
        ->select(i | 
            i.classifier->notEmpty() and
            i.classifier->asSequence()->first().oclIsKindOf(Class) and (
                i.classifier->asSequence()->first().name = 'Piece' or 
                i.classifier->asSequence()->first().name = 'King' or 
                i.classifier->asSequence()->first().name = 'Pawn' or 
                i.classifier->asSequence()->first().name = 'Queen' or 
                i.classifier->asSequence()->first().name = 'Rook' or 
                i.classifier->asSequence()->first().name = 'Bishop' or 
                i.classifier->asSequence()->first().name = 'Knight'
            )
        )
        ->collect(i | i.classifier->asSequence()->first().oclAsType(Class))
        ->asSet()
)]
[generateClass(c)/]
[/for]

[comment -- 2. Generowanie Board i GameBoard --/]
[generateBaseBoard(board)/]

[generateGameBoardSetup(board)/]
[/file]
[/template]

[template private generateClass(c : Class)]
class [c.name/](Piece):
    def symbol(self):
[if (c.name = 'Knight')]
        return 'N' if self.color == 'White' else 'n'
[else]
        return '[c.name.first(1)/]' if self.color == 'White' else '[c.name.first(1).toLowerCase()/]'
[/if]
[/template]

[template private generatePiece(board : Model)]
class Piece:
    def __init__(self, color, col, row):
        self.color = color
        self.col = col
        self.row = row

    def symbol(self):
        raise NotImplementedError("Subclasses must implement this method.")

    def position_indices(self):
        x = ord(self.col.lower()) - ord('a')
        y = self.row - 1
        return x, y

[/template]

[template private generateGameBoardSetup(board : Model)]
class GameBoard(Board):
    def __init__(self):
        super().__init__([board.packagedElement->filter(InstanceSpecification)->select(i | i.classifier->exists(c | i.classifier->asSequence()->first().name = 'Board')).slot->select(s | s.definingFeature.name = 'size')->asSequence()->first().value->first().eGet('value')/])
        self.move_history = ['['/][']'/]
        self.setup()

    def setup(self):
[for (p : InstanceSpecification | board.packagedElement->filter(InstanceSpecification)->select(i | 
    i.classifier->exists(c | i.classifier->asSequence()->first().name = 'Piece' or i.classifier->asSequence()->first().name = 'King' or i.classifier->asSequence()->first().name = 'Pawn' or c.name = 'Queen' or c.name = 'Rook' or c.name = 'Bishop' or c.name = 'Knight'))
  )]
        self.add_piece([p.classifier->asSequence()->first().name/]("[p.slot->select(s | s.definingFeature.name = 'color')->asSequence()->first().value->first().oclAsType(LiteralString).value/]", '[p.slot->select(s | s.definingFeature.name = 'col')->asSequence()->first().value->first().oclAsType(LiteralString).value/]', [p.slot->select(s | s.definingFeature.name = 'row')->asSequence()->first().value->first().oclAsType(LiteralInteger).value/]))
[/for]

if __name__ == "__main__":
    board = GameBoard()
    board.setup()
    board.print_board()
[/template]

[template private generateBaseBoard(board : Model)]
class Board:
    def __init__(self, size):
        self.size = size
        self.pieces = ['['/][']'/]

    def add_piece(self, piece):
        self.pieces.append(piece)

    def print_board(self):
        board = ['['/]['['/]"." for _ in range(self.size)] for _ in range(self.size)]
        for piece in self.pieces:
            x, y = piece.position_indices()
            if 0 <= x < self.size and 0 <= y < self.size:
                board['['/]y]['['/]x] = piece.symbol()

        col_labels = ['['/]chr(ord('a') + i) for i in range(self.size)]
        top_row = "    " + "   ".join(col_labels)
        divider = "  +" + "---+" * self.size

        print(top_row)
        for row_idx in reversed(range(self.size)):
            print(divider)
            row_str = f"{row_idx + 1} |"
            for col_idx in range(self.size):
                row_str += f" {board['['/]row_idx]['['/]col_idx]} |"
            print(row_str + f" {row_idx + 1}")
        print(divider)
        print(top_row)
[/template]
